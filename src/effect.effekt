
// interface宣言は操作を含む新しいエフェクトタイプを作成する。
interface Ask[A] {
  def ask(): A
}

interface Emit[A] {
  def emit(value: A): Unit
}

// 操作が一つならこのようにも宣言できる
effect ask2[A](): A
effect emit2[A](value: A): Unit

// effect宣言は既存のエフェクトのセットに名前をつける（エイリアスを作る）
// ↑と似ているが、パーサは区別しているようだ。
effect AskEmit[A] = {
  Ask[A],
  Emit[A]
}

def printAsk() : Unit / { Ask[String] } = {
  val value = do ask[String]()
  println(value)
}

def askHandler[R, A](a : A) { action: () => R / Ask[A] }: R / {} = {  
  try {  
    action()  
  } with Ask[A] {  
    def ask() = resume(a)  
  }
}

def emitHandler[R] { action: () => R / Emit[String] }: R / {} = {
  try {
    action()
  } with Emit[String] {
    def emit(value: String) = resume(println(value))
  }
}

def askExample() = {  
  with askHandler("ask value")
  printAsk()
}

def emitExample() = {
  with emitHandler
  do emit("Hello world!")
}

def askEmit[A](): Unit / { Ask[A], Emit[A] } = {
  val value = do ask[A]()
  do emit(value)
}

def exampleAskEmit() = {
  with askHandler("ask value")
  with emitHandler
  askEmit[String]()
}

def main() : Unit / {} = {
  askExample()
  emitExample()
  exampleAskEmit()
}